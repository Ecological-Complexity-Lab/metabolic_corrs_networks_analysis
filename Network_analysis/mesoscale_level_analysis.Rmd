---
title: "meso-sacle level analysis"
output: html_notebook
---

first- create the multilayer networks using the emln package. after that- I used them in another file called multi_analysis (saved on the desktop in a folder called "infomp modularity" so the infomap package would work). 
```{r}

#the input needs to be matrices so I took the igraphs (of common with singletons), turned them into matrices and used them in the multylayer function- that means that the first step needs to be the construction of igraphs as before

library(emln)

#negative weights to positive since the package will not work otherwise
E(WT_negative_p_igraph_df_s)$weight <- abs(E(WT_negative_p_igraph_df_s)$weight)
E(unevo_negative_p_igraph_df_s)$weight <- abs(E(unevo_negative_p_igraph_df_s)$weight)
E(evo_negative_p_igraph_df_s)$weight <- abs(E(evo_negative_p_igraph_df_s)$weight)
E(evoWT_negative_p_igraph_df_s)$weight <- abs(E(evoWT_negative_p_igraph_df_s)$weight)
E(mut_negative_p_igraph_df_s)$weight <- abs(E(mut_negative_p_igraph_df_s)$weight)


WT_pos_s_mat <- as.matrix(WT_positive_p_igraph_df_s,attr="weight",sparse=F)
WT_neg_s_mat <- as.matrix(WT_negative_p_igraph_df_s,attr="weight",sparse=F)

WT_multilayer <- create_multilayer_network(list_of_layers = list(WT_pos_s_mat, WT_neg_s_mat), bipartite = F,directed=F)
saveRDS(WT_multilayer, file="modularity/multi_nets/WT_multilayer_PCLRC.RData")

unevo_pos_s_mat <- as.matrix(unevo_positive_p_igraph_df_s,attr="weight",sparse=F)
unevo_neg_s_mat <- as.matrix(unevo_negative_p_igraph_df_s,attr="weight",sparse=F)

unevo_multilayer <- create_multilayer_network(list_of_layers = list(unevo_pos_s_mat, unevo_neg_s_mat), bipartite = F,directed=F)
saveRDS(unevo_multilayer, file="modularity/multi_nets/unevo_multilayer_PCLRC.RData")

evo_pos_s_mat <- as.matrix(evo_positive_p_igraph_df_s,attr="weight",sparse=F)
evo_neg_s_mat <- as.matrix(evo_negative_p_igraph_df_s,attr="weight",sparse=F)

evo_multilayer <- create_multilayer_network(list_of_layers = list(evo_pos_s_mat, evo_neg_s_mat), bipartite = F,directed=F)
saveRDS(evo_multilayer, file="modularity/multi_nets/evo_multilayer_PCLRC.RData")

evoWT_pos_s_mat <- as.matrix(evoWT_positive_p_igraph_df_s,attr="weight",sparse=F)
evoWT_neg_s_mat <- as.matrix(evoWT_negative_p_igraph_df_s,attr="weight",sparse=F)

evoWT_multilayer <- create_multilayer_network(list_of_layers = list(evoWT_pos_s_mat, evoWT_neg_s_mat), bipartite = F,directed=F)
saveRDS(evoWT_multilayer, file="modularity/multi_nets/evoWT_multilayer_PCLRC.RData")

mut_pos_s_mat <- as.matrix(mut_positive_p_igraph_df_s,attr="weight",sparse=F)
mut_neg_s_mat <- as.matrix(mut_negative_p_igraph_df_s,attr="weight",sparse=F)

mut_multilayer <- create_multilayer_network(list_of_layers = list(mut_pos_s_mat, mut_neg_s_mat), bipartite = F,directed=F)
saveRDS(mut_multilayer, file="modularity/multi_nets/mut_multilayer_PCLRC.RData")


#upload
WT_multilayer_net <- readRDS("modularity/multi_nets/WT_multilayer_PCLRC.RData")
unevo_multilayer_net <- readRDS("modularity/multi_nets/unevo_multilayer_PCLRC.RData")
evo_multilayer_net <- readRDS("modularity/multi_nets/evo_multilayer_PCLRC.RData")
evoWT_multilayer_net <- readRDS("modularity/multi_nets/evoWT_multilayer_PCLRC.RData")
mut_multilayer_net <- readRDS("modularity/multi_nets/mut_multilayer_PCLRC.RData")


```

after using the infomap on the HPC- uploading the results
```{r}
#the modules are made with a file called "multi_analysis.R" in a folder called "infomap-modularity" on the desktop. after that I copied the files into the drive and they are available for uploading here:
#read the files- four types of files per each bacteria- 
#1) info_object- the output of the 'run_infomap_multilayer' function
WT_info_object_multi <- read_rds("modularity/WT_info_object_multi_PCLRC.RData")
unevo_info_object_multi <- read_rds("modularity/unevo_info_object_multi_PCLRC.RData")
evo_info_object_multi <- read_rds("modularity/evo_info_object_multi_PCLRC.RData")
evoWT_info_object_multi <- read_rds("modularity/evoWT_info_object_multi_PCLRC.RData")
mut_info_object_multi <- read_rds("modularity/mut_info_object_multi_PCLRC.RData")

#2)the output of the 'create_multilayer_object' function
WT_multi_obj_multi <-read_rds("modularity/WT_multi_obj_multi_PCLRC.RData")
unevo_multi_obj_multi <-read_rds("modularity/unevo_multi_obj_multi_PCLRC.RData")
evo_multi_obj_multi <- read_rds("modularity/evo_multi_obj_multi_PCLRC.RData")
evoWT_multi_obj_multi <-read_rds("modularity/evoWT_multi_obj_multi_PCLRC.RData")
mut_multi_obj_multi <-read_rds("modularity/mut_multi_obj_multi_PCLRC.RData")


#3)modules df- notice the NA's because of the singletons. removed first column (row names-index)
WT_modules <- read_csv("modularity/multi_nets/module_list_WT_multilayer_net_PCLRC.csv") %>%select(-starts_with("."))
unevo_modules <- read_csv("modularity/multi_nets/module_list_unevo_multilayer_net_PCLRC.csv")%>%select(-starts_with("."))
evo_modules <- read_csv("modularity/multi_nets/module_list_evo_multilayer_net_PCLRC.csv")%>%select(-starts_with("."))
evoWT_modules <- read_csv("modularity/multi_nets/module_list_evoWT_multilayer_net_PCLRC.csv")%>%select(-starts_with("."))
mut_modules <- read_csv("modularity/multi_nets/module_list_mut_multilayer_net_PCLRC.csv")%>%select(-starts_with("."))


#just to check that the node_id and node_name are the same in all networks-

s <- WT_multi_obj_multi$nodes%>% arrange(node_id)
s_2 <- evoWT_multi_obj_multi$nodes%>% arrange(node_id)
s_3 <-  evo_multi_obj_multi$nodes%>% arrange(node_id)
s_4 <-  unevo_multi_obj_multi$nodes%>% arrange(node_id)

all.equal(s,s_3)

#NOTE- the state nodes are not the same in all networks (meaning node_id 1 can have a state node of 1 and 2 in one network and 3 and 4 in another)


#plotting
#plotting- notice I added filtering so we'll see only models with 10 or more nodes
modules_WT2 <- WT_modules%>% drop_na() %>% group_by(module) %>% count()
WT_plot <- ggplot(modules_WT2 %>% filter(n>=10), aes(x=module, y=n)) +
  geom_col(fill="coral",color="black")+ labs(title="WT", x="Module number", y="Module size")+theme_minimal()+theme(axis.title.x = element_text(size=14),axis.text = element_text(size = 10),plot.title = element_text( size=18))+xlim(0, 70)+ylim(0,530)

modules_unevo2 <- unevo_modules %>% drop_na() %>% group_by(module) %>% count()
unevo_plot <- ggplot(modules_unevo2 %>% filter(n>=10), aes(x=module, y=n)) +
  geom_col(fill="#339900",color="black")+ labs(title="unevolved", x="Module number", y="Module size")+theme_minimal()+theme(axis.title.x = element_text(size=14),axis.text = element_text(size = 10),plot.title = element_text( size=18))+xlim(0, 70)+ylim(0,530)

modules_evo2 <- evo_modules %>% drop_na()%>% group_by(module) %>% count()
evo_plot <- ggplot(modules_evo2 %>% filter(n>=10), aes(x=module, y=n)) +
  geom_col(fill="cornflowerblue",color="black")+ labs(title="evolved", x="Module number", y="Module size")+theme_minimal()+theme(axis.title.x = element_text(size=14),axis.text = element_text(size = 10),plot.title = element_text( size=18))+xlim(0, 70)+ylim(0,530)

modules_evoWT2 <- evoWT_modules %>% drop_na()%>% group_by(module) %>% count()
evoWT_plot <- ggplot(modules_evoWT2 %>% filter(n>=10), aes(x=module, y=n)) +
  geom_col(fill="#d11141",color="black")+ labs(title="evolved-WT", x="Module number", y="Module size")+theme_minimal()+theme(axis.title.x = element_text(size=14),axis.text = element_text(size = 10),plot.title = element_text(size=18))+xlim(0, 70)+ylim(0,530)

modules_mut2 <- mut_modules %>% drop_na()%>% group_by(module) %>% count()
mut_plot <- ggplot(modules_mut2 %>% filter(n>=10), aes(x=module, y=n)) +
  geom_col(fill="#9999CC",color="black")+ labs(title="mut", x="Module number", y="Module size")+theme_minimal()+theme(axis.title.x = element_text(size=14),axis.text = element_text(size = 10),plot.title = element_text(size=18))+xlim(0, 70)+ylim(0,530)

figure <- ggarrange(WT_plot+ rremove("ylab") + rremove("xlab"),unevo_plot+ rremove("ylab") + rremove("xlab"),evo_plot + rremove("ylab") + rremove("xlab"), evoWT_plot + rremove("ylab") + rremove("xlab"),mut_plot + rremove("ylab") + rremove("xlab"), # remove axis labels from plots
                    labels = NULL,
                    ncol = 3, nrow = 2)+theme(plot.margin = margin(0.5,0.5,0.5,0.5, "cm")) 
figure <- annotate_figure(figure, left = textGrob("Module size", rot = 90, vjust = 1, gp = gpar(cex = 1.3)),
                bottom = textGrob("Module", gp = gpar(cex = 1.3), vjust = -0.7),top = text_grob("Size of modules",  color = "black", size = 16))


#ggsave("/Users/sharon/Library/Mobile Documents/com~apple~CloudDocs/CD_585_r_0.4/plots_and_tables/plots/modularity_multi.pdf",figure, width = 10,height = 6,)
ggsave("plots_and_tables/plots/modularity_multi_10_or_more_nodes.pdf",figure, width = 13,height = 6)





```

NMI- 
```{r}


#first- upload the modules csv (section called-modules by infomap)
# create the confusion matrix:
create_NMI_matrix <- function(network_par_1,network_par_2){
  network_par_1$node_layer <- paste0(network_par_1$node_id,"_",network_par_1$layer_id)
  network_par_2$node_layer <- paste0(network_par_2$node_id,"_",network_par_2$layer_id)

  nodes_in_both <- intersect(network_par_1$node_layer,network_par_2$node_layer)
  network_par_1 <- network_par_1%>% drop_na()%>% filter( node_layer %in% nodes_in_both )
  print(nrow(network_par_1))
  network_par_2 <- network_par_2%>% drop_na()%>% filter( node_layer %in% nodes_in_both )
  print(nrow(network_par_2))
  network_par_1_modules <- network_par_1 %>% group_by(module) %>% count()
  network_par_2_modules <- network_par_2 %>% group_by(module) %>% count()
  mat <- matrix(0,nrow=max(as.numeric(network_par_1_modules$module)),ncol=max(as.numeric(network_par_2_modules$module)))
  for (metabolite in network_par_1$node_layer){ 
    mod_in_1 <- as.numeric(filter(network_par_1, node_layer==metabolite)$module)
    mod_in_2 <- as.numeric(filter(network_par_2, node_layer==metabolite)$module)
    mat[mod_in_1,mod_in_2]=mat[mod_in_1,mod_in_2]+1
  }
  return(mat)}

NMI_networks <- function(list_df){
  res <- as.data.frame(matrix(NA, nrow=length(list_df), ncol=length(list_df)))
  for (set_1_num in c(1:length(list_df))){
    for (set_2_num in c(1:length(list_df))){
      if (set_1_num!=set_2_num){#can change to > since the matrix is symmetric, but need all to compare to random
      NMI_mat <- create_NMI_matrix(list_df[[set_1_num]],list_df[[set_2_num]])
      delete_rows=c();delete_cols=c()
          NMI_mat=as.data.frame(NMI_mat) #now- delete rows/columns with sum==0 (since we deleted un-shared nodes and it couased the function NMI to stop)
          for (row in c(1:nrow(NMI_mat))){
            if (sum(NMI_mat[row,])==0){
              delete_rows <- append(delete_rows,row)
            }
          }
          for (col in c(1:ncol(NMI_mat))){
            if (sum(NMI_mat[,col])==0){
              delete_cols <- append(delete_cols,col)
            }
          }
          if (length(delete_rows)>0){
            NMI_mat <- NMI_mat[-delete_rows,]
          }
          if (length(delete_cols)>0){
            NMI_mat <- NMI_mat[,-delete_cols]
          }
          NMI_value <- infomapecology::NMI(NMI_mat)
      res[set_1_num,set_2_num] <- NMI_value
      }}}
  return (res)
}

NMI_all_bac <- NMI_networks(list(WT_modules,unevo_modules,evo_modules,evoWT_modules, mut_modules))%>%`colnames<-`(c("WT","unevo","evo","evoWT","mut"))%>%`row.names<-`(c("WT","unevo","evo","evoWT","mut"))

pdf("plots_and_tables/tables/NMI_multilayer.pdf", height=11, width=10)
grid.table(round(NMI_all_bac,4))
dev.off()

```

node_roles
```{r}
#needed functions- by klil
library(magrittr)

z_score_multi <- function(i, modules, stats) {
  m_i <- modules$module[modules$state_node == i]
  k_m_i <- modules$k_m[modules$state_node == i]
  avg_k <- stats$k_m_avg[stats$module == m_i]
  sd_k <- stats$k_m_sd[stats$module == m_i]
  return ((k_m_i - avg_k)/sd_k)
}

c_score_multi <- function(i, modules, edges) {
  c_sum_i <- c()
  if (i %in% edges$sn_from) {
    i_edges <- filter(edges, sn_from == i)
    for (t in unique(i_edges$m_to)) {
      k_i_t <- sum(i_edges$m_to == t)
      k_i <- as.numeric(modules$k_total[modules$state_node == i])
      c_sum_i <- c(c_sum_i, (k_i_t / k_i)**2)
    }
  }
  if (i %in% edges$sn_to) {
    i_edges <- filter(edges, sn_to == i)
    for (t in unique(i_edges$m_from)) {
      k_i_t <- sum(i_edges$m_from == t)
      k_i <- as.numeric(modules$k_total[modules$state_node == i])
      c_sum_i <- c(c_sum_i, (k_i_t / k_i)**2)
    }
  }
  return(c_score_i <- as.numeric(1-sum(c_sum_i)))
}

assign_roles <-  function(modules) {
  output <- mutate(modules, 
                   role = case_when(modules$z_score <= 2.5 & modules$c_score <= 0.62 ~ 'peripheral',
                                    modules$z_score <= 2.5 & modules$c_score > 0.62 ~ 'connector',
                                    modules$z_score > 2.5 & modules$c_score <= 0.62 ~ 'module hub',
                                    modules$z_score > 2.5 & modules$c_score > 0.62 ~ 'network hub',
                                    is.nan(modules$z_score) == T & modules$c_score <= 0.62 ~ 'peripheral',
                                    is.nan(modules$z_score) == T & modules$c_score > 0.62 ~ 'connector',
                                    is.na(modules$z_score) == T & modules$c_score <= 0.62 ~ 'peripheral',
                                    is.na(modules$z_score) ==T & modules$c_score > 0.62 ~ 'connector'))
  return(output)
}


#first- create a df of the links with the module of each node- by state node
roles_fun <- function(modules_list,multi_net){
  expanded_intra <-multi_net$extended_ids %>% 
    left_join(modules_list, by = c('node_from' = 'node_id', 'layer_from' = 'layer_id')) %>% 
    left_join(modules_list, by = c('node_to' = 'node_id', 'layer_from' = 'layer_id')) %>% 
    dplyr::select(sn_from = state_node.x, sn_to = state_node.y, node_from, node_to, 
                  m_from = module.x, m_to = module.y, weight)
  main_graph <- graph.data.frame(expanded_intra[,c(1:2)], directed = F, vertices = modules_list$state_node) #v are state nodes
  
  modules_list %<>% mutate(k_total = igraph::degree(main_graph)) 
  expanded_list <- expanded_intra
  
  # degree within modules
  k_m <- data.frame(matrix(nrow = 0, ncol = 2))
  names(k_m) <- c('state_node', 'k_m')
  for (m in unique(modules_list$module)) {
    m_state_nodes <- filter(modules_list, module == m) 
    # edges where both nodes are in m 
    m_edges <- filter(expanded_list, m_from == m & m_to == m) 
    m_graph <- graph.data.frame(m_edges[,c(1:2)], directed = F, vertices = m_state_nodes$state_node)
    #V(m_graph)$type <- V(m_graph)$name %in% expanded_intra[,"sn_from"]
    # m_matrix <- as_incidence_matrix(m_graph, names = T, attr = 'weight', sparse = F)
    m_degrees <- data.frame(state_node = m_state_nodes$state_node, k_m = igraph::degree(m_graph)) 
    k_m <- rbind(k_m, m_degrees)
  }
  modules_list %<>% inner_join(k_m, by = "state_node") 
  
  
  
  # average degree in each module
  k_m_avg <- data.frame(matrix(nrow = 0, ncol = 3))
  for (m in unique(modules_list$module)) {
    k_m_avg %<>% rbind(c(m, mean(modules_list$k_m[modules_list$module == m]),
                         sd(modules_list$k_m[modules_list$module == m])))  
  }
  names(k_m_avg) <- c('module', 'k_m_avg', 'k_m_sd')
  
  
  modules_list %<>% arrange(state_node)
  Z <- lapply(modules_list$state_node, modules_list, k_m_avg, FUN = z_score_multi) 
  modules_list %<>% mutate(z_score = unlist(Z))
  
  C <- lapply(sort(modules_list$state_node), modules_list, expanded_intra, FUN = c_score_multi)
  modules_list %<>% mutate(c_score = unlist(C)) 
  
  super_list <- assign_roles(modules_list)
  write.csv(super_list, paste0("modularity/super_list_",str_split_1(deparse(substitute(multi_net)), "_")[1],"_PCLRC.csv"))
  
  #NOTE THAT SMALL MODULES THAT ARE DISCONNECTED FROM THE NETWORK CAN LEAD TO Z VALUE OF NA since the sd is 0- are not in the plot

  return(super_list)} 



WT_roles <- roles_fun(WT_modules,WT_multilayer_net)
unevo_roles <- roles_fun(unevo_modules,unevo_multilayer_net)
evo_roles <- roles_fun(evo_modules,evo_multilayer_net)
evoWT_roles <- roles_fun(evoWT_modules,evoWT_multilayer_net)
mut_roles <- roles_fun(mut_modules,mut_multilayer_net)

#plots- notice that first the plot creation was build in the function and I took it out

WT_super <- read_csv("modularity/super_list_WT_PCLRC.csv")%>%select(-starts_with(".")) 
unevo_super <- read_csv("modularity/super_list_unevo_PCLRC.csv")%>%select(-starts_with("."))
evo_super <- read_csv("modularity/super_list_evo_PCLRC.csv")%>%select(-starts_with("."))
evoWT_super <- read_csv("modularity/super_list_evoWT_PCLRC.csv")%>%select(-starts_with("."))
mut_super <- read_csv("modularity/super_list_mut_PCLRC.csv")%>%select(-starts_with("."))


   # Z-c plot

super_list_list <- list("WT"=WT_super,"unevo"=unevo_super,"evo"=evo_super,"evoWT"=evoWT_super, "mut"=mut_super)
plot_list=list()


for (list_num in c(1:length(super_list_list))){
  super_list_modi <- super_list_list[[list_num]] %>% mutate_at(7, ~replace(., is.na(.), 0)) #NOTE- to add the nodes with z values of NA I changes it to be 0- check if ok!
  SAM_point_pos<- super_list_modi %>% 
             filter(node_id==1957& layer_id==1)
  SAM_point_neg<- super_list_modi %>% 
             filter(node_id==1957 & layer_id==2)
  plot <- ggplot(super_list_modi, aes(x = c_score, y = z_score, color = role)) +
    geom_point(size=2) +
    scale_color_manual(values = c('#66a182', '#00798c', '#d1495b',"#edae49")) +
    guides(colour = guide_legend(override.aes = list(size=6)))+
  
    geom_hline(yintercept = 2.5) +
    geom_vline(xintercept = 0.62) +
    scale_x_continuous(expand = c(0, 0), limits = c(0, 1.05)) + 
   labs(title = names(super_list_list)[list_num], x=NULL, y=NULL,color = 'Role')+
    theme_bw() + 
    theme(axis.text=element_text(size=20),axis.title=element_text(size=25),legend.text = element_text(size=20),legend.title = element_text(size=25),legend.key.size = unit(1, 'cm'),legend.position = "left",plot.margin = margin(0.8,0.8,0.8,0.8, "cm"),plot.title = element_text(face="bold", size=22))+
        theme(panel.border = element_blank(), panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))+
      geom_point(data=SAM_point_pos, 
             aes(x = c_score, y = z_score), 
             shape=23, fill="blue", color="darkred", size=5)+
      geom_point(data=SAM_point_neg, 
             aes(x = c_score, y = z_score), 
             shape=23, fill="green", color="darkred", size=5)
  plot_list <- append(plot_list,list(plot))
}

figure <- ggarrange(plotlist=plot_list, # remove axis labels from plots
                    ncol = 3, nrow = 2,common.legend = TRUE,legend="right")
figure <- annotate_figure(figure, left = textGrob("Z",  hjust = 0, gp = gpar(cex = 2.3)),
                bottom = textGrob("C", gp = gpar(cex = 2.6),vjust = 0))

ggsave("plots_and_tables/plots/roles_z_c_PCLRC_SAM_highlighted.pdf",plot=figure,  width=17, height=11)




WT_super_g <- WT_super%>% group_by(role) %>% tally()
unevo_super_g <- unevo_super%>%group_by(role) %>% tally()
evo_super_g <- evo_super%>%group_by(role) %>% tally()
evoWT_super_g <- evoWT_super%>%group_by(role) %>% tally()
mut_super_g <- mut_super%>%group_by(role) %>% tally()

roles <- cbind(WT_super_g,unevo_super_g$n,evo_super_g$n,evoWT_super_g$n,mut_super_g$n) %>%`colnames<-`(c("role","WT","unevo","evo","evoWT","mut")) 

ratio <- as.data.frame(roles[,-1] %>% apply(2,function(x){x/sum(x)})%>%round(5)) %>%add_column("role"=roles$role, .before=T)

roles_long <- melt(roles, id="role") #if needed- change to ratio


roles_plot <- ggplot(data=roles_long, aes(x=variable, y=value, fill=role)) +geom_bar(stat="identity", position=position_dodge(),show.legend = FALSE) + 
  scale_fill_manual(values=c("#66a182",
                             "#00798c",
                             "#d1495b",
                             "#edae49",
                             "#9999CC"))+
  labs(title = "Node Roles",
       y = "Count", x = "") +
   theme_bw() +
  facet_wrap(~ role, scales = "free") +theme(strip.text = element_text(size = 18),axis.text=element_text(size=14),title=element_text(size=16),panel.spacing = unit(1, "lines"))
 

roles_plot


ggsave(filename=paste0("plots_and_tables/plots/roles_all_multi_PCLRC.pdf"), plot = roles_plot, width=10, height=7)



#state nodes of the same node with different roles:

WT_super_n <- WT_super%>% group_by(node_id,role) %>% tally()
 
WT_super_stay <- WT_super_n%>%filter(n==2)
WT_super_change <- WT_super_n%>%filter(n==1)


WT_super_change_l_Z <- WT_super_change%>%filter(role %in% c("module hub","network hub"))

```


transition matrix

```{r}

WT_super <- read_csv("modularity/super_list_WT_PCLRC.csv")%>%select(-starts_with(".")) 
unevo_super <- read_csv("modularity/super_list_unevo_PCLRC.csv")%>%select(-starts_with("."))
evo_super <- read_csv("modularity/super_list_evo_PCLRC.csv")%>%select(-starts_with("."))
evoWT_super <- read_csv("modularity/super_list_evoWT_PCLRC.csv")%>%select(-starts_with("."))
mut_super <- read_csv("modularity/super_list_mut_PCLRC.csv")%>%select(-starts_with("."))


trans <- data.frame(matrix(c(nrow(WT_super %>%filter(role=="peripheral")),nrow(unevo_super %>%filter(role=="peripheral")),nrow(evo_super %>%filter(role=="peripheral")),nrow(evoWT_super %>%filter(role=="peripheral")),nrow(mut_super %>%filter(role=="peripheral")), nrow(WT_super %>%filter(role=="connector")),nrow(unevo_super %>%filter(role=="connector")),nrow(evo_super %>%filter(role=="connector")),nrow(evoWT_super %>%filter(role=="connector")),nrow(mut_super %>%filter(role=="connector")), nrow(WT_super %>%filter(role=="module hub")) ,nrow(unevo_super %>%filter(role=="module hub")),nrow(evo_super %>%filter(role=="module hub")),nrow(evoWT_super %>%filter(role=="module hub")),nrow(mut_super %>%filter(role=="module hub")),nrow(WT_super %>%filter(role=="network hub")),nrow(unevo_super %>%filter(role=="network hub")),nrow(evo_super %>%filter(role=="network hub")),nrow(evoWT_super %>%filter(role=="network hub")),nrow(mut_super %>%filter(role=="network hub"))), ncol=4, byrow = FALSE),row.names = c("WT","unevolved","evo","evoWT","mut"))%>%`colnames<-`(c("P","C","MH","NH"))

a <-list(WT_super[,c(3,5,11)], unevo_super[,c(3,5,11)],evo_super[,c(3,5,11)],evoWT_super[,c(3,5,11)],mut_super[,c(3,5,11)])

s <- a %>% purrr::reduce(full_join, by=c("layer_id",'node_name'))%>%`colnames<-`(c("layer_id","node_name","WT","unevolved","evo","evoWT","mut"))
mat <- data.frame(matrix(NA, ncol=17, nrow=0))
for (i_1 in 1:ncol(s)){
  if (i_1 >= 3){
    for (i_2 in 1:ncol(s)){
      if (i_2 >= 3 & i_2!=i_1){
        row <- c(paste0(colnames(s[,i_1]),"_",colnames(s[,i_2])), 
                 nrow(filter(s, s[,i_1]=="peripheral" & s[,i_2]=="peripheral")),
                 nrow(filter(s, s[,i_1]=="peripheral" & s[,i_2]=="connector")),
                 nrow(filter(s, s[,i_1]=="peripheral" & s[,i_2]=="module hub")),
                 nrow(filter(s, s[,i_1]=="peripheral" & s[,i_2]=="network hub")),
                 nrow(filter(s, s[,i_1]=="connector" & s[,i_2]=="peripheral")),
                 nrow(filter(s, s[,i_1]=="connector" & s[,i_2]=="connector")),
                 nrow(filter(s, s[,i_1]=="connector" & s[,i_2]=="module hub")),
                 nrow(filter(s, s[,i_1]=="connector" & s[,i_2]=="network hub")),
                 nrow(filter(s, s[,i_1]=="module hub" & s[,i_2]=="peripheral")),
                 nrow(filter(s, s[,i_1]=="module hub" & s[,i_2]=="connector")),
                 nrow(filter(s, s[,i_1]=="module hub" & s[,i_2]=="module hub")),
                 nrow(filter(s, s[,i_1]=="module hub" & s[,i_2]=="network hub")),
                 nrow(filter(s, s[,i_1]=="network hub" & s[,i_2]=="peripheral")),
                 nrow(filter(s, s[,i_1]=="network hub" & s[,i_2]=="connector")),
                 nrow(filter(s, s[,i_1]=="network hub" & s[,i_2]=="module hub")),
                 nrow(filter(s, s[,i_1]=="network hub" & s[,i_2]=="network hub")))
        print(row)
          mat <- rbind(mat,row) 
        }}}
}

colnames(mat) <- (c("bact","P->P","P->C","P->MH","P->NH","C->P","C->C","C->MH","C->NH","MH->P","MH->C","MH->MH","MH->NH","NH->P","NH->C","NH->MH","NH->NH")) 
rownames(mat) <- mat[,1]
mat[,1] <- NULL
long <- melt(t(mat))
long$value <- as.numeric(long$value)
long <- filter(long, Var2 %in% c("WT_unevolved","unevolved_evo","WT_evo","WT_evoWT","evo_evoWT","evo_mut","WT_mut","unevo_mut"))

e <- ggplot(long, mapping = aes(x = Var2, y = value, fill =  Var1)) + 
    geom_bar(position= "stack", stat = "identity")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5))+ theme(text = element_text(size = 25)) 
ggsave(file="plots_and_tables/plots/roles_change.pdf", e, width=11, height=8)


long$org <- str_split_1(as.character(long$Var1), "->")[1]
out <- strsplit(as.character(long$Var1),'->') 
out <- as.data.frame(do.call(rbind, out))
long <- cbind(long, out[,1])
long$`out[, 1]`

plot_list={}
for (bacts in c("WT_unevolved","unevolved_evo","WT_evo","WT_evoWT","evo_evoWT")){
  plot=ggplot(long %>%filter(Var2==bacts), mapping = aes(x =`out[, 1]`, y = value, fill =  Var1)) + 
    geom_col(position= "fill")+labs(title = bacts,) + theme(text = element_text(size = 15)) +scale_y_continuous(labels = scales::percent)+theme(legend.position = "none")+xlab(NULL)+ylab(NULL)
  plot_list=append(plot_list,list(plot))

}

plot_list[[1]]

s <- arrangeGrob(
  grobs = plot_list)
figure <- annotate_figure(s, left = textGrob("Percentage\n", rot = 90, vjust = 1, gp = gpar(cex = 1.7)),
                bottom = textGrob("Original Role", gp = gpar(cex = 1.7)),fig.lab.size=0.5,fig.lab.face = "bold")

ggsave(file="plots_and_tables/plots/roles_change_percentage.pdf", figure, width=11, height=8)


f <- ggplot(long %>%filter(Var2=="WT_unevolved"), mapping = aes(x =`out[, 1]`, y = value, fill =  Var1)) + 
    geom_col(position= "fill")+labs(title = "WT_unevolved") + theme(text = element_text(size = 10)) +scale_y_continuous(labels = scales::percent)+xlab(NULL)+ylab(NULL)+theme(legend.position = "bottom")

ggsave(file="plots_and_tables/plots/roles_change_WT_unevo.pdf", f, width=11, height=8)

#what nodes change their roles?

a <- set_tbl_1[,1:3]
met_anno <-left_join(s, a, by=c("node_name"="cluster"))




```

